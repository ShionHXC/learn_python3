# python基础

## 数据类型

### 整数

### 浮点数

### 字符串  

    r''表示''内部的字符串默认不转义
    '''...'''的格式表示多行内容

### 布尔值

    True False 注意大小写
    布尔值可以用and、or和not运算。

### 空值
    None

### 变量

### 常量 
    通常用全部大写的变量名表示常量: PI = 3.14159265359

    / 除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数
    // 称为地板除，两个整数的除法仍然是整数 取整
    % 取余数

## 字符串和编码

    Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了
    本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：

    %运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。

    
占位符|替换内容
--|:--:
%d|整数
%f|浮点数
%s|字符串
%x|十六进制整数 

    如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串

## 使用list 和 tuple

### lsit 一种有序的集合

    list相当于 JavaScript 中的数组  len() 获取长度   list(-1) 直接获取最后一位元素

    append() 追加元素到末尾
    insert(index, content) 把元素插入到指定的位置
    pop() 删除末尾元素
    pop(i) 删除指定索引位置元素
    要把某个元素替换成别的元素，可以直接赋值给对应的索引位置
    ist里面的元素的数据类型也可以不同
    list元素也可以是另一个list

### tuple 元组

    tuple和list非常类似，但是tuple一旦初始化就不能修改
    只有1个元素的tuple定义时必须加一个逗号,，来消除歧义 t = (1,)
    tuple 的 list 元素 可以被修改 tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。 指向的这个list本身是可变的！
## 循环
### for...in 循环
    如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。
    >>> list(range(5))
    [0, 1, 2, 3, 4]
### while 循环

    break 提前结束循环
    continue 结束当前循环

## 使用dict和set

### dict 
    Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。
    dict的key必须是不可变对象。
    要删除一个key，用pop(key)方法
    
### set

    set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。
    set可以看成数学意义上的无序和无重复元素的集合

# 函数
## 调用函数
### 数据类型转换
    int()函数可以把其他数据类型转换为整数
    float() str() bool()
### 返回多个值
    原来返回值是一个tuple！
    但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，
    所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。
### 默认参数
    必选参数在前，默认参数在后，否则Python的解释器会报错
    默认参数必须指向不变对象！
### 可变参数
    def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
    定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：
### 关键字参数
    
    因个人原因，本人申请2019年6月28日辞职。

# 高级特性
## 切片
    L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。
    如果第一个索引是0，还可以省略：
    L[-1]取倒数第一个元素，那么它同样支持倒数切片
    >>> L[-2:]
    ['Bob', 'Jack']
    >>> L[-2:-1]
    ['Bob']

    字符串'xxx'也可以看成是一种list，每个元素就是一个字符。
    Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。

## 迭代
    因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。

    默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。


    通过collections模块的Iterable类型判断 判断是否是可迭代类型
    Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：
    for i,v in enumerate(['a', 'b', 'c']):
        print(i,v)
    
## 列表生成式
        是Python内置的非常简单却强大的可以用来创建list的生成式。
        >>> list(range(1, 11))
        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

        isinstance函数可以判断一个变量

## 生成器
    在Python中，这种一边循环一边计算的机制，称为生成器：generator。
    创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。

    我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？

    如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：

    这里，最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。
    在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了

    但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：

